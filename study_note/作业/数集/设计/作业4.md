软件环境：Quartus Prime 18.0
Device family：Cyclone IV E
## 作业内容
设计 3-8 译码器、8-3 优先编码器、参数化的译码器、参数化的编码器、4 位格雷码计数器

## 设计译码器
### 3-8 译码器
**代码实现：**

```verilog
`timescale 1 ns/ 1 ps
module decoder_38(
	input wire[2:0]in,
	output reg[7:0]y
	);
	always@(*)
		case(in)
			3'b000: y = 8'b0000_0001;
			3'b001: y = 8'b0000_0010;
			3'b010: y = 8'b0000_0100;
			3'b011: y = 8'b0000_1000;
			3'b100: y = 8'b0001_0000;
			3'b101: y = 8'b0010_0000;
			3'b110: y = 8'b0100_0000;
			3'b111: y = 8'b1000_0000;
		endcase
endmodule 
```

RTL viewer
![400](https://raw.githubusercontent.com/acdefg/cdn/main/obsidian/20221104180601.png)
>使用的 testbench 与下一项相同，不重复列出

**测试结果：**
波形图：
![](https://raw.githubusercontent.com/acdefg/cdn/main/obsidian/20221104180804.png)
输出信息：
![150](https://raw.githubusercontent.com/acdefg/cdn/main/obsidian/20221104180826.png)

### 参数化译码器
**代码实现**

```verilog
`timescale 1 ns/ 1 ps
module decoder #(
	parameter n=3,
			  m=1<<n
	)(
	input wire[n-1:0]in,
	output reg[m-1:0]y
	);
	//one-hot
	always@(*)y=1<<in;  //1向左移in位
endmodule 
```
其中，y 可以称作独热码，即有多少个状态就有多少比特，而且只有一个比特为 1，其他全为 0 的一种码制。

testbench：

```verilog
`timescale 1 ns/ 1 ps
module decoder_vlg_tst();
parameter N = 2;
parameter M = 1<<N;
reg [N-1:0] in;                                               
wire [M-1:0]  y;
                       
decoder_coder #(.n(N), .m(M)) //更改参数
	i1( 
	.in(in),
	.y(y)
);

integer i;
initial                                                
begin
	for(i=0; i<M; i=i+1) begin
		in = i;  //测试0---M-1的输入
		#10;
	end 
	#10 $stop;  //使仿真暂停在这里，不会结束
end

initial 
	$monitor("in = %b ---> y = %b ", in, y);
                                                 
endmodule
```


## 实验收获
$stop
含参例化
