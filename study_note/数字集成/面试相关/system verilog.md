## packed unpacked
在 SystemVerilog 中，packed 数组和 unpacked 数组主要有以下区别：

**一、存储方式**
1.  **packed 数组**：
    -   以紧凑的方式存储，类似于连续的位序列。
    -   例如，一个 8 位的 packed 数组可以被视为一个连续的 8 位二进制序列存储在内存中。
2.  **unpacked 数组**：
    -   每个元素都独立地存储在内存中，类似于传统编程语言中的数组存储方式。
    -   对于一个由多个字节组成的 unpacked 数组，每个元素都有自己独立的存储空间。
**二、声明方式**
1.  **packed 数组**：
    -   使用 `[bit_vector_size]` 的语法进行声明，其中 `bit_vector_size` 表示位宽。
    -   例如：`logic [7:0] packed_array;` 声明了一个 8 位宽的 packed 数组。
2.  **unpacked 数组**：
    -   使用传统的数组声明方式，例如 `logic [array_size] unpacked_array;`，其中 `array_size` 表示数组的大小。
    -   例如：`logic [7] unpacked_array;` 声明了一个包含 8 个元素的 unpacked 数组。
**三、访问方式**
1.  **packed 数组**：
    -   可以作为一个整体进行赋值和操作，也可以通过位索引的方式访问特定的位。
    -   例如，可以使用 `packed_array = 8'b10101010;` 进行整体赋值，或者使用 `packed_array[3]` 访问第 4 位。
2.  **unpacked 数组**：
    -   通过索引访问单个元素，类似于传统数组的访问方式。
    -   例如：`unpacked_array[3] = 1'b1;` 表示将 unpacked_array 数组的第 4 个元素赋值为 1。
**四、操作灵活性**
1.  **packed 数组**：
    -   在进行位操作和逻辑操作时更加高效，因为可以直接对位进行操作。
    -   例如，可以使用位拼接操作符 `{}` 将多个 packed 数组拼接在一起。
2.  **unpacked 数组**：
    -   在进行复杂的数据结构操作和对单个元素进行操作时更加方便。
    -   可以对单个元素进行赋值、比较和其他操作，而不需要考虑位级的细节。
**五、内存占用**
1.  **packed 数组**：
    -   通常占用较少的内存空间，因为它们以紧凑的方式存储。
    -   对于大规模的数组，packed 数组可以节省内存。
2.  **unpacked 数组**：
    -   由于每个元素都独立存储，可能占用更多的内存空间。
    -   但是，对于小尺寸的数组，内存占用的差异可能不太明显。
