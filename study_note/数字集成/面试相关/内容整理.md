## 亚稳态
亚稳态是指触发器无法在某个规定时间段内达到一个可确认的状态。当一个触发器进入亚稳态时，既无法预测该单元的输出电平，也无法预测何时输出才能稳定在某个正确的电平上。在这个稳定期间，触发器输出一些中间级电平，或者可能处于振荡状态，并且这种无用的输出电平可以沿信号通道上的各个触发器级联式传播下去。

**亚稳态的解决方法**
·1 降低系统时钟
·2 用反应更快的 FF（flip-flop）
·3 引入同步机制，防止亚稳态传播
·4 改善时钟质量，用边沿变化快速的时钟信号
· 关键是器件使用比较好的工艺和时钟周期的裕量要大

### 两级触发器可以防止产生亚稳态
**什么是亚稳态？为什么两级触发器可以防止亚稳态传播？**
亚稳态是指触发器无法在规定的时间段内到达一个可以确认的状态。使用两级触发器来使用异步电路同步化的电路叫做“一位同步器”，只能对一位异步信号进行同步。

两级触发器可以防止亚稳态传播的原理：假设第一级触发器的输入不满足其建立保持时间，它在第一个脉冲沿到来之后输出的数据就为亚稳态，那么在下一个脉冲沿到来之前，其输出的亚稳态数据在一段恢复时间后必须稳定下来，而且稳定得数据必须满足第二级触发器的建立时间，如果都满足了，在下一个脉冲沿到来时，第二级触发器将不会出现亚稳态，因为其输入端的数据满足其建立保持时间。同步器有效的条件：第一级触发器进入到亚稳态后的恢复时间+第二级触发器的建立时间<=时钟周期

## 跨时钟域问题
跨时钟域(CDC)问题分类及对应解决方法
#### 单 bit 数据的传输（电平或者脉冲信号）
1、同步时钟域：
频率相等，相差为 0——同频零相位差时钟：为相同时钟，可以直接采
频率相等，相差固定——同频恒定相位差时钟：需要满足保持/建立时间
频率不等，相差可变——非同频可变相位差时钟，又可分为：
整数倍时钟（频率成倍数）
低频采高频：数据要至少保持目的时钟 clk2 两个周期；有可能出现亚稳态，还可能出现漏采
高频采低频：保证建立/保持时间；有可能出现亚稳态，不可能出现漏采
有理数倍时钟（频率不成倍数）
​​​​​​​​​​​​​​
低频采高频：数据要至少保持目的时钟 clk2 两个周期：肯定出现亚稳态
高频采低频：数据要至少保持目的时钟 clk2 两个周期：肯定出现亚稳态
2、异步时钟域：
高频采低频
​​​​​​​
电平同步器（双锁存）
边沿同步器
脉冲同步器
低频采高频
​​​​​​​​​​​​​​
脉冲同步器
注：
上述几种同步器方法，统称为多级寄存器处理或打拍；关于数据需要保持的时间，不管是快域采慢域，还是慢域采快域，数据都有至少保持慢域的一个时钟周期

#### 多 bit 数据传输（数据总线、地址总线）：
握手信号方法
异步 FIFO（使用 DPRAM 双口ram）


## FIFO
FIFO在硬件上是一种地址依次自增的Simple Dual Port RAM，按读数据和写数据工作的时钟域是否相同分为同步FIFO和异步FIFO，其中同步FIFO是指读时钟和写时钟为同步时钟，常用于数据缓存和数据位宽转换；异步FIFO通常情况下是指读时钟和写时钟频率有差异，即由两个异步时钟驱动的FIFO，由于读写操作是独立的，故常用于多比特数据跨时钟域处理。
### 同步 fifo
同步 FIFO 的意思是说 FIFO 的读写时钟是同一个时钟，不同于异步 FIFO，异步 FIFO 的读写时钟是完全异步的。同步 FIFO 的对外接口包括时钟，清零，读请求，写请求，数据输入总线，数据输出总线，空以及满信号。下面分别对同步 FIFO 的对外接口信号作一描述：
1． 时钟，输入，用于同步 FIFO 的读和写，上升沿有效；
2． 清零，输入，异步清零信号，低电平有效，该信号有效时，FIFO 被清空；
3． 写请求，输入，低电平有效，该信号有效时，表明外部电路请求向 FIFO 写入数据；
4． 读请求，输入，低电平有效，该信号有效时，表明外部电路请求从 FIFO 中读取数据；
5． 数据输入总线，输入，当写信号有效时，数据输入总线上的数据被写入到 FIFO 中；
6． 数据输出总线，输出，当读信号有效时，数据从 FIFO 中被读出并放到数据输出总线上；
7． 空，输出，高电平有效，当该信号有效时，表明 FIFO 中没有任何数据，全部为空；
8． 满，输出，高电平有效，当该信号有效时，表明 FIFO 已经满了，没有空间可用来存贮数据。

下面的框图主要描述同步FIFO的内部结构，画出框图有助于对电路结构的理解，同样也有助于RTL代码的编写 ：

![](https://raw.githubusercontent.com/acdefg/cdn/main/obsidian/20240321100721.png)

#### example
```verilog
/******************************************************
A fifo controller verilog description.
******************************************************/
module fifo(datain, rd, wr, rst, clk, dataout, full, empty);
input [7:0] datain;
input rd, wr, rst, clk;
output [7:0] dataout;
output full, empty;
wire [7:0] dataout;
reg full_in, empty_in;
reg [7:0] mem [15:0];
reg [3:0] rp, wp;
assign full = full_in;
assign empty = empty_in;
// memory read out
assign dataout = mem[rp];
// memory write in
always@(posedge clk) begin
    if(wr && ~full_in) mem[wp]<=datain;
end
// memory write pointer increment
always@(posedge clk or negedge rst) begin
    if(!rst) wp<=0;
    else begin
      if(wr && ~full_in) wp<= wp+1'b1;
    end
end
// memory read pointer increment
always@(posedge clk or negedge rst)begin
    if(!rst) rp <= 0;
    else begin
      if(rd && ~empty_in) rp <= rp + 1'b1;
    end
end
// Full signal generate
always@(posedge clk or negedge rst) begin
    if(!rst) full_in <= 1'b0;
    else begin
      if( (~rd && wr)&&((wp==rp-1)||(rp==4'h0&&wp==4'hf)))
          full_in <= 1'b1;
      else if(full_in && rd) full_in <= 1'b0;
    end
end
// Empty signal generate
always@(posedge clk or negedge rst) begin
    if(!rst) empty_in <= 1'b1;
    else begin
      if((rd&&~wr)&&(rp==wp-1 || (rp==4'hf&&wp==4'h0)))
        empty_in<=1'b1;
      else if(empty_in && wr) empty_in<=1'b0;
    end
end
endmodule
```

### 异步 fifo
异步 FIFO 的一些重要概念：
1、FIFO数据宽度：FIFO一次读写的数据位宽。（与RAM数据位宽相同）
2、FIFO存储深度：FIFO可存储的固定位宽数据的个数。（与RAM存储深度相同）
3、读时钟：在每个读时钟的边沿来临时读数据。
4、写时钟：在每个写时钟的边沿来临时写数据。
5、读指针：指向下一个要读的地址，读完后自动加1。
6、写指针：指向下一个要写的地址，写完后自动加1。
读写指针其实就是读写的地址，只不过不能任意设置，只能连续自增。
7、空/满标志：为了保证FIFO的正确读写，而不发生写溢出或读空的情况，需要提供写满和读空的标志来提醒外部控制器此状态下不能再进行写/读操作。
根据上述重要概念可以定义出异步 FIFO 的基本对外接口：写时钟、读时钟、写使能、读使能、写满标志、读空标志、写入数据总线、读出数据总线以及读/写复位。因为我们所设计的是异步 FIFO，它的读写部分不是在同一个时钟域内工作，所以可以将它们划分为写时钟域和读时钟域，在两个时钟域各自控制本时钟域内的信号，并将两个时钟域内的一些有关信号进行跨时钟域处理来联合判断 FIFO 状态。
其中 WIDTH 是 RAM 数据总线的位宽，DEPTH 是 RAM 的存储深度（即 RAM 中可以存下 DEPTH 个宽度为 WIDTH 的数据），ADDR 是地址总线的宽度（即 DEPTH = 2^ADDR ，异步 FIFO 中深度必须是 2^n）
![](https://raw.githubusercontent.com/acdefg/cdn/main/obsidian/20240321101313.png)

### 格雷码
由于多位地址各位变化时间不同，异步时钟对其进行采样时数值可能为不同于地址变化丧后数值的其他值，异步产生错误的空标志和满标志，以致于产生 FIFO 的操作错误。  
格雷码是一种在相邻计数值之间只有一位发生变化的编码方式。可以看出，若读写地址采用格雷码编码方式，就可以解决上面的问题。
#### **多位二进制码如何转化为格雷码？**

**![](https://images2018.cnblogs.com/blog/1377659/201805/1377659-20180521164033434-823887354.png)**

换一种描述方法：

![](https://images2018.cnblogs.com/blog/1377659/201805/1377659-20180521164245869-1861014618.png)

verilog 代码实现就一句：assign  gray_code = (bin_code>>1)  ^  bin_code;
#### **在格雷码域如何判断空与满？**
![](https://raw.githubusercontent.com/acdefg/cdn/main/obsidian/20240321101611.png)
这张图是五位二进制和格雷码的对应表，可以看出，低四位二进制每 16 个数据一循环，而超出 16 个数据后最高位会从 0 变成 1，这第五位意味着什么？意味着这一位可以表示循环的次数，即这一位为 1 就代表了低二进制已经循环过 16 个数据了，正在处于第二轮循环中。

这给如何判断 “写满” 标志带来了启发，何谓 “写满” ？就是写指针正好超过了读指针一整个存储深度并同处于同一个位置。如何表示写指针盖过了读指针一圈呢？就使用上面说的第五位来判断，其实有效地址只有四位，第五位是用来存储盖过的圈数的。所以可以看见，前面的代码中，地址总线宽度其实都是 5 位的。

所以判断 “写满” 标志的方法就是：写指针和读指针最高位的数据不同，而其他位都相同。

 这里直接给出结论：

　　**判断读空时：需要读时钟域的格雷码rgray_next和被同步到读时钟域的写指针rd2_wp每一位完全相同;**

　　**判断写满时：需要写时钟域的格雷码 wgray_next 和被同步到写时钟域的读指针 wr2_rp 高两位不相同，其余各位完全相同；**

### reference link