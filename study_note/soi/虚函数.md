## 虚函数
### 纯虚函数和普通虚函数的区别
**纯虚函数** 和**普通虚函数** 都是 C++ 中用于实现多态的工具，但它们之间有一些重要的区别。**普通虚函数（Virtual Function）** 
普通虚函数是基类中的虚函数，它有具体的实现，并且可以在派生类中被重写（覆盖）。普通虚函数允许基类指针或引用指向派生类对象，并在运行时动态调用派生类的实现。

**特点** ： 
- **有实现** ：普通虚函数在基类中有具体的实现。
- **可重写** ：派生类可以重写（覆盖）基类的普通虚函数，但如果派生类不重写，基类的实现将被使用。
- **可实例化基类** ：包含普通虚函数的类是可以实例化的，除非该类有纯虚函数。
**例子** ：

```cpp
#include <iostream>
using namespace std;

class Shape {
public:
    // 普通虚函数：有实现
    virtual void draw() {
        cout << "Drawing a Shape!" << endl;
    }

    virtual ~Shape() {}
};

class Circle : public Shape {
public:
    void draw() override {
        cout << "Drawing a Circle!" << endl;
    }
};

int main() {
    Shape* shape = new Circle();
    shape->draw();  // 调用 Circle 类的 draw 函数

    delete shape;
    return 0;
}
```
**输出** ：

```css
Drawing a Circle!
```
在上面的例子中，`draw` 是一个普通虚函数，在 `Shape` 类中有具体的实现。尽管如此，`Circle` 类重写了这个函数，因此在通过基类指针调用时，实际调用的是派生类 `Circle` 中的实现。

---

**纯虚函数（Pure Virtual Function）** 纯虚函数是基类中的虚函数，它没有实现，且被强制要求派生类实现该函数。纯虚函数使得基类成为**抽象类** ，抽象类不能直接实例化，只能作为其他类的基类。**特点** ： 
- **没有实现** ：纯虚函数在基类中没有具体实现，只有声明。
 
- **强制重写** ：派生类必须实现纯虚函数，否则派生类也将变成抽象类，不能实例化。
 
- **基类不可实例化** ：包含纯虚函数的类是一个抽象类，不能直接创建对象。
**语法** ：
纯虚函数的声明通常是这样的：

```cpp
virtual void func() = 0;
```

**例子** ：
```cpp
#include <iostream>
using namespace std;

class Shape {
public:
    // 纯虚函数：没有实现
    virtual void draw() = 0;

    virtual ~Shape() {}
};

class Circle : public Shape {
public:
    void draw() override {
        cout << "Drawing a Circle!" << endl;
    }
};

int main() {
    // Shape shape;  // 错误，不能实例化抽象类

    Shape* shape = new Circle();
    shape->draw();  // 调用 Circle 类的 draw 函数

    delete shape;
    return 0;
}
```

**输出** ：
```css
Drawing a Circle!
```
在这个例子中，`draw` 是一个纯虚函数，因此 `Shape` 类是一个抽象类，不能直接实例化对象。在 `Circle` 类中实现了 `draw` 函数，允许通过基类指针实例化并调用派生类的实现。

---

**区别总结** ：
| 特性 | 普通虚函数 | 纯虚函数 | 
| --- | --- | --- | 
| 是否有实现 | 有实现 | 没有实现 | 
| 派生类是否必须实现 | 可选，如果派生类不实现，则使用基类的实现 | 必须实现，否则派生类也变为抽象类，不能实例化 | 
| 基类是否可以实例化 | 可以实例化基类 | 不能实例化基类，基类是抽象类 | 
| 类是否抽象 | 不一定（除非有纯虚函数） | 一定是抽象类 | 
| 目的 | 提供一个可以被派生类重写的虚函数 | 定义一个接口，强制派生类实现该函数 | 

**使用场景** ： 
- **普通虚函数** ：当你需要提供一个默认的实现，并且允许派生类根据需要重写时使用。
- **纯虚函数** ：当你希望在基类中定义接口，而不提供具体实现时使用，通常用于定义抽象基类，强制派生类提供实现。

---

**总结**  
- **普通虚函数** ：有实现，派生类可重写。基类可以实例化。
- **纯虚函数** ：没有实现，派生类必须重写，基类不能实例化。

### void draw() override 和 virtual void draw()
`virtual` 和 `override` 的区别
| 特性 | virtual void draw() | void draw() override | 
| --- | --- | --- | 
| 定义位置 | 在基类中定义，用于声明虚函数 | 在派生类中定义，用于重写基类的虚函数 | 
| 作用 | 表示该函数是虚函数，可以在派生类中重写 | 明确表示派生类中的函数是重写基类的虚函数，增强可读性和安全性 | 
| 是否强制检查 | 不进行重写检查，允许派生类自行决定是否重写 | 强制检查，确保函数确实是重写了基类的虚函数 | 
| 使用时机 | 基类中的虚函数声明 | 派生类中重写基类的虚函数 | 

**总结**  
- **`virtual void draw()`** ：用于在基类中声明虚函数，表示该函数是可以被派生类重写的。
- **`void draw() override`** ：用于在派生类中重写基类的虚函数，`override` 关键字提供了编译时的检查，确保该函数确实是重写了基类的虚函数。
如果你在派生类中使用 `override`，编译器会帮助你检测是否正确重写了基类的虚函数，从而避免一些常见的错误，比如函数签名不匹配或者忘记重写函数。